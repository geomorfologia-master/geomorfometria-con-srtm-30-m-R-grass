---
title: "Práctica de Geomorfometría con SRTM 30 m (R y/o GRASS GIS)"
author: "Curso de Geomorfología — UASD"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: false
    df_print: paged
fontsize: 11pt
lang: es
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  eval = FALSE)
```

# Presentación

Esta práctica propone **≥10 ejercicios independientes** (elige **uno**), cada uno realizable en **~60 min** usando **R** en consola, **GRASS GIS** en modo texto (Bash), o **combinando** ambos. Todos se basan en el **DEM SRTM 30 m** (≈1 arc-sec). Los temas siguen el repertorio de **geomorfometría** descrito por Hengl & Reuter (ed.), p. ej., preparación de DEM, parámetros locales y regionales, redes de drenaje y visibilidad.

> **Nota sobre GRASS.** La estructura *database → location → mapset* y la convención de nombres de módulos (p. ej., `r.*` para ráster, `v.*` para vector) se usarán de forma intensiva.

---

# Objetivos

- Trabajar con **SRTM 30 m** para derivar parámetros geomorfométricos locales y regionales.  
- Practicar flujos de **preparación del DEM** (clip, reproyección, limpieza básica).  
- Poner en práctica módulos clave de **GRASS GIS** (`r.slope.aspect`, `r.param.scale`, `r.watershed`, `r.viewshed`) y funciones análogas en **R** (`terra::terrain`, etc.).

---

# Requisitos y materiales

- **R ≥ 4.2**, disponible en el servidor con paquetes como: `terra`, `exactextractr` (opcional), `rgrass` (para invocar GRASS desde R), `spatialEco` (opcional para visibilidad en R).
- **GRASS GIS ≥ 7.8**, disponible en servidor, en modo texto/Bash. Bash es un intérprete de línea de comandos y lenguaje de scripting para sistemas tipo Unix (Linux, macOS, y ahora WSL en Windows). En un servidor RStudio, esta se encuentra en la pestaña "**Terminal**".
- Un mosaico o *tile* **SRTM 30 m** en GeoTIFF (o posibilidad de descargarlo) para **recortarlo** y subirlo al servidor.

---

# Estructura de trabajo (resumen)

1. **Datos/AOI**: escoge un AOI (extensión) pequeña para trabajar rápido.  
2. **Elige 1 ejercicio** de la lista (sección _Ejercicios_).  
3. **Usa una de las rutas**: _Solo R_, _Solo GRASS_, o _Mixta_.  
4. **Entrega**: mapa(s) PNG/GeoTIFF y un breve _informe_ (5–10 líneas) con método, parámetros y observaciones.

---

# Antes de empezar

## 1) Obtener y preparar SRTM (opción R o Bash)

> Si ya tienes un `srtm.tif` recortado a tu AOI, salta a **Creación del LOCATION/MAPSET en GRASS**.

### Opción R

```{r}
# Paquetes
if (!requireNamespace("terra", quietly = TRUE)) install.packages("terra")
library(terra)

# Define tu AOI (cambia estos límites a tu zona)
aoi <- ext(-70.2, -69.8, 18.3, 18.6)  # xmin, xmax, ymin, ymax (ejemplo)

# Opción A: cargar un GeoTIFF local ya descargado
# srtm <- rast("data/srtm_30m.tif")

# Para este guion: si no tienes datos reales, crea un ráster DEM sintético (SOLO para probar)
if (!exists("srtm")) {
  srtm <- rast(ncol=600, nrow=600, xmin=xmin(aoi), xmax=xmax(aoi), ymin=ymin(aoi), ymax=ymax(aoi), crs="EPSG:4326")
  values(srtm) <- 50 + 500*exp(-((xFromCell(srtm,1:ncell(srtm))+69.95)^2 + (yFromCell(srtm,1:ncell(srtm))-18.45)^2)*20)
  names(srtm) <- "srtm_demo"  # <- reemplaza por tu SRTM real cuando lo tengas
}

dir.create("salidas", showWarnings = FALSE)
writeRaster(srtm, "salidas/srtm.tif", overwrite=TRUE)
```

### Opción Bash (descarga aproximada)

```{bash}
mkdir -p datos && cd datos
# (Ejemplo genérico; ajusta URL/tiles a tu zona si usas un espejo de SRTM)
# wget "https://.../srtm_XX_YY.tif" -O srtm.tif
```

> **Recomendación**: trabajar inicialmente en **WGS84 (EPSG:4326)** para SRTM crudo y reproyectar al final si lo necesitas.

---

## 2) Crear LOCATION/MAPSET en GRASS (modo texto)

En el terminal (Bash) de RStudio:

```{bash}
# Ajusta rutas a tu home
export GISDBASE="$HOME/grassdata"
export LOC="srtm_wgs84"
mkdir -p "$GISDBASE"

# Opción A: crear LOCATION por EPSG
grass -c EPSG:4326 -e "$GISDBASE/$LOC"

# Crea un MAPSET de trabajo
grass "$GISDBASE/$LOC/PERMANENT" --exec g.mapset -c mapset=alumno01

# Importa el SRTM y define región
grass "$GISDBASE/$LOC/alumno01" --exec r.in.gdal input="$PWD/salidas/srtm.tif" output=srtm30m
grass "$GISDBASE/$LOC/alumno01" --exec g.region raster=srtm30m -p
```

> En los ejemplos siguientes asumimos `GISDBASE=$HOME/grassdata`, `LOC=srtm_wgs84`, `MAPSET=alumno01` y el ráster `srtm30m` disponible.

---

# Ejercicios (elige **uno**)

Cada ejercicio contiene **Ruta A (Solo R)** y **Ruta B (Solo GRASS)**. Haz las dos rutas y compara resultados.

---

## Ejercicio 1 — Preparación del DEM (clip, reproyección ligera, suavizado opcional)

**Propósito.** Establecer un DEM listo para análisis geomorfométrico (recorte a AOI, comprobar proyección y resolución, suavizado opcional para ruido).

### Ruta A — Solo R

```{r}
library(terra)
dem <- rast("salidas/srtm.tif")

# Clip a un AOI (edita 'aoi' en la sección previa)
dem_aoi <- crop(dem, aoi)

# (Opcional) reproyecta a UTM local si necesitas distancias/áreas métricas
# Ej.: Santo Domingo ~ UTM 19N EPSG:32619
dem_utm <- project(dem_aoi, "EPSG:32619", method="bilinear")

# (Opcional) suavizado (3x3) para reducir micro-ruido
w <- matrix(1, 3, 3); w <- w/sum(w)
dem_smooth <- focal(dem_utm, w=w, na.policy="omit")

writeRaster(dem_utm,    "salidas/dem_utm.tif",    overwrite=TRUE)
writeRaster(dem_smooth, "salidas/dem_smooth.tif", overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec g.region raster=srtm30m
# (Opcional) suavizado 3x3
grass "$GISDBASE/$LOC/alumno01" --exec r.neighbors input=srtm30m output=dem_smooth size=3 method=average
```

---

## Ejercicio 2 — Pendiente, aspecto y sombreado

**Propósito.** Derivar pendiente/aspecto y un **hillshade** para realzar relieve.

### Ruta A — Solo R

```{r}
library(terra)
dem <- if (file.exists("salidas/dem_utm.tif")) rast("salidas/dem_utm.tif") else rast("salidas/srtm.tif")

slp  <- terrain(dem, v="slope",  unit="radians")
asp  <- terrain(dem, v="aspect", unit="radians")
hs   <- shade(slope=slp, aspect=asp, angle=45, direction=315) # 45° elev, NW

writeRaster(slp, "salidas/slope_rad.tif", overwrite=TRUE)
writeRaster(asp, "salidas/aspect_rad.tif", overwrite=TRUE)
writeRaster(hs,  "salidas/hillshade.tif",  overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec r.slope.aspect elevation=srtm30m slope=slope aspect=aspect format=degrees
# hillshade
grass "$GISDBASE/$LOC/alumno01" --exec r.shaded.relief map=srtm30m output=hillshade altitude=45 azimuth=315
```

---

## Ejercicio 3 — Northness y Eastness (componentes del aspecto)

**Propósito.** Transformar el aspecto en **northness = cos(aspect)** y **eastness = sin(aspect)** para análisis estadístico.

### Ruta A — Solo R

```{r}
library(terra)
asp <- rast("salidas/aspect_rad.tif")
northness <- cos(asp); eastness <- sin(asp)
writeRaster(northness, "salidas/northness.tif", overwrite=TRUE)
writeRaster(eastness,  "salidas/eastness.tif",  overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
# Nota: en el Ejercicio 2, 'aspect' salió en grados; conviértelo a radianes en r.mapcalc
# northness = cos(aspect_rad), eastness = sin(aspect_rad)
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "aspect_rad = aspect * (pi()/180.0)"
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "northness = cos(aspect_rad)"
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "eastness  = sin(aspect_rad)"
```

---

## Ejercicio 4 — Rugosidad (TRI) y *roughness*

**Propósito.** Medir textura topográfica local (relieve relativo).

### Ruta A — Solo R

```{r}
library(terra)
dem <- if (file.exists("salidas/dem_utm.tif")) rast("salidas/dem_utm.tif") else rast("salidas/srtm.tif")
tri <- terrain(dem, v="TRI")         # Terrain Ruggedness Index (3x3)
rfh <- terrain(dem, v="roughness")   # max-min (3x3)
writeRaster(tri, "salidas/tri.tif", overwrite=TRUE)
writeRaster(rfh, "salidas/roughness.tif", overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec r.param.scale input=srtm30m output=tri method=roughness size=5
# (Alternativa) r.neighbors + r.mapcalc para max-min
grass "$GISDBASE/$LOC/alumno01" --exec r.neighbors input=srtm30m output=max5 size=5 method=maximum
grass "$GISDBASE/$LOC/alumno01" --exec r.neighbors input=srtm30m output=min5 size=5 method=minimum
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "rough5 = max5 - min5"
```

---

## Ejercicio 5 — TPI y clasificación simple de formas del terreno

**Propósito.** Calcular **Topographic Position Index** (TPI) y clasificar formas (cumbre, ladera, valle) con umbrales sencillos.

### Ruta A — Solo R

```{r}
library(terra)
dem <- if (file.exists("salidas/dem_utm.tif")) rast("salidas/dem_utm.tif") else rast("salidas/srtm.tif")

# TPI a varias escalas (3x3 y 11x11)
tpi3  <- terrain(dem, v="TPI")  # 3x3
w11   <- matrix(1, 11, 11); w11 <- w11/sum(w11)
tpi11 <- dem - focal(dem, w=w11, na.policy="omit")

# Clasificación naive (ajusta umbrales por histograma)
tpi <- tpi11
m   <- c(-Inf, -5, 1,  -5, 5, 2,   5, Inf, 3) # 1=valle, 2=ladera, 3=cumbre (ejemplo métrico)
rcl <- matrix(m, ncol=3, byrow=TRUE)
forms <- classify(tpi, rcl)

writeRaster(tpi3,  "salidas/tpi3.tif",  overwrite=TRUE)
writeRaster(tpi11, "salidas/tpi11.tif", overwrite=TRUE)
writeRaster(forms, "salidas/formas_simple.tif", overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
# TPI ~ elev - promedio ventana
grass "$GISDBASE/$LOC/alumno01" --exec r.neighbors input=srtm30m output=mean11 size=11 method=average
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "tpi11 = srtm30m - mean11"
# Clasificación con umbrales (ajusta a tu zona)
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "form = if(tpi11<-5,1, if(tpi11>5,3,2))"
```

---

## Ejercicio 6 — Curvas hipsométricas (AOI o subcuencas)

**Propósito.** Resumir la distribución de áreas por elevación (curva hipsométrica) y el **índice hipsométrico**.

### Ruta A — Solo R

```{r}
library(terra)
dem <- if (file.exists("salidas/dem_utm.tif")) rast("salidas/dem_utm.tif") else rast("salidas/srtm.tif")
brk <- seq(floor(min(values(dem), na.rm=TRUE)), ceiling(max(values(dem), na.rm=TRUE)), by=25)
cls <- classify(dem, cbind(brk[-length(brk)], brk[-1], 1:(length(brk)-1)))
ft  <- as.data.frame(freq(cls))
colnames(ft) <- c("bin","n")
ft$elev_mid <- (brk[-length(brk)] + brk[-1])/2
ft$area_m2  <- ft$n * prod(res(dem))  # área por celda
ft$cumA     <- cumsum(ft$area_m2)
ft$Arel     <- ft$cumA / sum(ft$area_m2)
ft$Erel     <- (ft$elev_mid - min(brk)) / diff(range(brk))
write.csv(ft, "salidas/hipsometria.csv", row.names=FALSE)
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec r.stats -an input=srtm30m > salidas/elev_area.txt
# (Opcional) usar r.report para clases de elevación
```

---

## Ejercicio 7 — Red de drenaje desde el DEM

**Propósito.** Obtener **acumulación de flujo** y **red de drenaje** umbralizada.

### Ruta A — R + rgrass (invocando GRASS desde R)

```{r}
if (!requireNamespace("rgrass", quietly = TRUE)) install.packages("rgrass")
library(rgrass)
# Inicializa rgrass apuntando a tu GRASS ya creado
initGRASS(gisBase = Sys.getenv("GISBASE"),
          gisDbase = file.path(Sys.getenv("HOME"), "grassdata"),
          location = "srtm_wgs84", mapset = "alumno01", override = TRUE)

execGRASS("g.region", raster = "srtm30m")
execGRASS("r.watershed",
          parameters = list(elevation = "srtm30m", accumulation = "accum", drainage = "drain", stream = "streams", threshold = 2000),
          flags = c("overwrite"))
execGRASS("r.thin", parameters = list(input = "streams", output = "streams_thin"), flags = c("overwrite"))
execGRASS("r.to.vect", parameters = list(input = "streams_thin", output = "streams_v", type = "line"), flags = c("overwrite"))

# Traer a R (opcional)
acc  <- read_RAST("accum")
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec r.watershed elevation=srtm30m accumulation=accum drainage=drain stream=streams threshold=2000
grass "$GISDBASE/$LOC/alumno01" --exec r.thin input=streams output=streams_thin --overwrite
grass "$GISDBASE/$LOC/alumno01" --exec r.to.vect input=streams_thin output=streams_v type=line --overwrite
```

---

## Ejercicio 8 — Delimitación de cuenca a partir de un punto de salida

**Propósito.** Delinear la **cuenca vertiente** de un vertedero (coordenadas conocidas).

### Ruta A — R + rgrass

```{r}
if (!requireNamespace("rgrass", quietly = TRUE)) install.packages("rgrass")
library(rgrass)
initGRASS(gisBase = Sys.getenv("GISBASE"),
          gisDbase = file.path(Sys.getenv("HOME"), "grassdata"),
          location = "srtm_wgs84", mapset = "alumno01", override = TRUE)

# Define tu punto de salida en coords del LOCATION (EPSG:4326)
out_x <- -69.95; out_y <- 18.45

# Asegúrate de tener 'drain' (dirección de flujo) del ejercicio 7
execGRASS("r.water.outlet",
          parameters = list(input = "drain", coordinates = paste(out_x, out_y, sep=","), output = "basin"),
          flags = c("overwrite"))

# Traer la cuenca a R (opcional)
basin <- read_RAST("basin")
```

### Ruta B — Solo GRASS

```{bash}
echo "x|y
-69.95|18.45" > salidas/outlet.csv

grass "$GISDBASE/$LOC/alumno01" --exec v.in.ascii input=salidas/outlet.csv output=outlet separator=pipe x=1 y=2 --overwrite
grass "$GISDBASE/$LOC/alumno01" --exec r.water.outlet input=drain coordinates=-69.95,18.45 output=basin --overwrite
```

---

## Ejercicio 9 — Topographic Wetness Index (TWI)

**Propósito.** Calcular **TWI = ln(a / tanβ)** donde *a* es el área acumulada específica y *β* la pendiente en radianes.

### Ruta A — R + rgrass

```{r}
if (!requireNamespace("rgrass", quietly = TRUE)) install.packages("rgrass")
library(rgrass)
initGRASS(gisBase = Sys.getenv("GISBASE"),
          gisDbase = file.path(Sys.getenv("HOME"), "grassdata"),
          location = "srtm_wgs84", mapset = "alumno01", override = TRUE)

# Derivar pendiente en radianes y acumulación en celdas
execGRASS("r.slope.aspect", parameters = list(elevation="srtm30m", slope="slp_rad", format="radians"), flags = c("overwrite"))
execGRASS("r.watershed", parameters = list(elevation="srtm30m", accumulation="acc_cells"), flags = c("overwrite"))

# En GRASS: área específica aproximada sca = acc_cells * (ewres()*nsres())
execGRASS("r.mapcalc", parameters = list(expression = "sca = acc_cells * (ewres() * nsres())"), flags = c("overwrite"))
execGRASS("r.mapcalc", parameters = list(expression = "twi = log((sca + (ewres()*nsres())) / tan(slp_rad))"), flags = c("overwrite"))

# Traer TWI a R (opcional)
twi <- read_RAST("twi")
```

### Ruta B — Solo GRASS

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec r.slope.aspect elevation=srtm30m slope=slp_rad format=radians --overwrite
grass "$GISDBASE/$LOC/alumno01" --exec r.watershed elevation=srtm30m accumulation=acc_cells --overwrite
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "sca = acc_cells * (ewres() * nsres())" --overwrite
grass "$GISDBASE/$LOC/alumno01" --exec r.mapcalc "twi = log((sca + (ewres()*nsres())) / tan(slp_rad))" --overwrite
```

---

## Ejercicio 10 — **Viewshed** (línea de vista) desde un observador

**Propósito.** Calcular visibilidad binaria desde un punto (torre/antena).

### Ruta A — Solo R (se usa `spatialEco`)

```{r}
if (!requireNamespace("spatialEco", quietly = TRUE)) install.packages("spatialEco")
library(terra); library(spatialEco)
dem <- if (file.exists("salidas/dem_utm.tif")) rast("salidas/dem_utm.tif") else rast("salidas/srtm.tif")
obs <- c(xmin(dem)+2000, ymin(dem)+2000)   # ajusta
vs  <- spatialEco::viewshed(raster::raster(dem), x=obs[1], y=obs[2], h1=10) # 10 m antena
vs  <- rast(vs)
writeRaster(vs, "salidas/viewshed.tif", overwrite=TRUE)
```

### Ruta B — Solo GRASS

```{bash}
# Observador: coord X,Y (del LOCATION) y altura observador (m)
grass "$GISDBASE/$LOC/alumno01" --exec r.viewshed input=srtm30m output=viewshed coordinate=-69.95,18.45 observer_elevation=10 --overwrite
```

---

# Qué entregar

En una carpeta `salidas/`:

- GeoTIFF/PNG con resultados principales (p. ej., `slope_rad.tif`, `hillshade.tif`, `streams_v.gpkg`, etc.).  
- Un archivo `README.md` (5–10 líneas) indicando:
  - AOI, proyección, resolución.  
  - Parámetros usados y justificación (p. ej., umbral de acumulación).  
  - Observaciones: artefactos, limitaciones, y mejoras posibles.

---

# Consejos y notas

- Al trabajar con **drenaje**, revisa que tus resultados no estén afectados por **depresiones** espurias. `r.watershed` suele ser robusto; si es necesario, evalúa estrategias de preprocesamiento (suavizado ligero o parámetros).  
- La **importación** de DEMs en GRASS se hace con `r.in.gdal`, y la visualización/zoom con `g.region`/`d.rast`.  
- Puedes integrar GRASS en R con `rgrass` (ver ejercicios 7–9) para mantener un flujo reproducible en un único .Rmd.

---

# Apéndice — Ejecutar GRASS “sin entrar” (modo `--exec`)

Puedes encadenar comandos sin abrir la shell interactiva:

```{bash}
grass "$GISDBASE/$LOC/alumno01" --exec g.region raster=srtm30m
grass "$GISDBASE/$LOC/alumno01" --exec r.slope.aspect elevation=srtm30m slope=slope aspect=aspect
```

> Esto permite integrarlo fácilmente en guiones Bash o RMarkdown.
